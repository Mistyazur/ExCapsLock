#include "keyboardhook.h"
#include "keysequence.h"
#include "cmdpalette.h"
#include "CmdItem/wincontrollor.h"
#include "TlHelp32.h"
#include <QTime>
#include <QDebug>


CmdPalette *g_cmdPalette = nullptr;

void KeyPress(WORD key)
{
    INPUT input[2] = {0};
    input[0].type = input[1].type = INPUT_KEYBOARD;
    input[0].ki.wVk = input[1].ki.wVk = key;
    input[0].ki.dwFlags = 0;
    input[1].ki.dwFlags = KEYEVENTF_KEYUP;
    ::SendInput(_countof(input), input, sizeof(INPUT));
}
void KeyDown(WORD key)
{
    INPUT input[1] = {0};
    input[0].type = INPUT_KEYBOARD;
    input[0].ki.wVk = key;
    input[0].ki.dwFlags = 0;
    ::SendInput(_countof(input), input, sizeof(INPUT));
}
void KeyUp(WORD key)
{
    INPUT input[1] = {0};
    input[0].type = INPUT_KEYBOARD;
    input[0].ki.wVk = key;
    input[0].ki.dwFlags = KEYEVENTF_KEYUP;
    ::SendInput(_countof(input), input, sizeof(INPUT));
}

void SwitchWindowWithSameOwner()
{
    // Get foreground window process id and window handle

    HWND hWnd = ::GetForegroundWindow();
    if (hWnd == NULL)
        return;

    DWORD dwForegroundPid;
    ::GetWindowThreadProcessId(hWnd, &dwForegroundPid);

    // Get processes

    QHash<DWORD, QString> procIdNameHash;
    HANDLE hProcessSnap;
    PROCESSENTRY32 pe32 = {sizeof(PROCESSENTRY32), };

    hProcessSnap = ::CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (INVALID_HANDLE_VALUE == hProcessSnap)
        return;

    if (::Process32First(hProcessSnap, &pe32))
    {
        do {

            procIdNameHash.insert(pe32.th32ProcessID, QString::fromWCharArray(pe32.szExeFile));

        } while (::Process32Next(hProcessSnap, &pe32));
    }

    ::CloseHandle(hProcessSnap);

    // Bring tagert windowt to front

    WINDOWINFO winInfo = {sizeof(WINDOWINFO), };
    HWND hTargetWnd = NULL;

    while ((hWnd = ::GetWindow(hWnd, GW_HWNDNEXT)) != NULL)
    {
        ::GetWindowInfo(hWnd, &winInfo);
        if (!(winInfo.dwStyle & WS_DISABLED)
                && (winInfo.dwStyle & WS_VISIBLE)
                && !(winInfo.dwExStyle & WS_EX_TRANSPARENT))
        {
            if ((winInfo.rcWindow.left != 0) &&
                    (winInfo.rcWindow.top != 0) &&
                    (winInfo.rcWindow.right != 0) &&
                    (winInfo.rcWindow.bottom != 0))
            {
                DWORD dwPid;
                ::GetWindowThreadProcessId(hWnd, &dwPid);
                if (dwPid == dwForegroundPid)
                {
                    WinControllor::bringToFront(hWnd);
                    return;
                }
                else
                {
                    const QString &foregroundProcName = procIdNameHash.value(dwForegroundPid, "");
                    const QString &procName = procIdNameHash.value(dwPid, "");
                    if ((hTargetWnd == NULL)
                            && (!foregroundProcName.isEmpty())
                            && (foregroundProcName == procName))
                        hTargetWnd = hWnd;
                }
            }
        }
    }

    if (hTargetWnd != NULL)
        WinControllor::bringToFront(hTargetWnd);
}

LRESULT CALLBACK KbHookProc(int nCode, WPARAM wParam, LPARAM lParam)
{
    static KeySequence keySeq = {};
    static uint nKeySeq = 0;
    static QTime tCLHold = QTime();
    PKBDLLHOOKSTRUCT pKey = (PKBDLLHOOKSTRUCT)lParam;

//    qDebug()<<"KEY:"<<wParam<<pKey->vkCode<<(pKey->flags & LLKHF_INJECTED);
//    return CallNextHookEx(NULL, nCode, wParam, lParam);

    // Esc to reset palette.
    if (pKey->vkCode == VK_ESCAPE)
    {
        if ((wParam == WM_KEYDOWN))
        {
            // Reset command
            if (g_cmdPalette->isVisible())
            {
                return true;
            }
        }
        else if (wParam == WM_KEYUP)
        {
            // Reset command
            if (g_cmdPalette->isVisible())
            {
                g_cmdPalette->reset();
                return true;
            }
        }
        return CallNextHookEx(NULL, nCode, wParam, lParam);
    }

    // Key event injected was simulated.
    if (pKey->flags & LLKHF_INJECTED) {
        // Simulated keys are generated by capslock plus other keys,
        // it can't be hooked because simulated keys are discarded when capslock down.
        if (keySeq.startsWith(VK_CAPITAL))
            return CallNextHookEx(NULL, nCode, wParam, lParam);
    }

    // Modifier
    if (keySeq.isEmpty())
        if ((pKey->vkCode == VK_LWIN)
                || (pKey->vkCode == VK_RWIN)
                || (pKey->vkCode == VK_LMENU)
                || (pKey->vkCode == VK_RMENU)
                || (pKey->vkCode == VK_LCONTROL)
                || (pKey->vkCode == VK_RCONTROL)
                || (pKey->vkCode == VK_LSHIFT)
                || (pKey->vkCode == VK_RSHIFT))
            return CallNextHookEx(NULL, nCode, wParam, lParam);

    if (wParam == WM_KEYDOWN)
    {
        // Caps Lock hold down
        if (keySeq.isEmpty())
        {
            if ((pKey->vkCode == VK_CAPITAL))
                tCLHold.isValid() ? tCLHold.restart() : tCLHold.start();
        }

        // Add to key sequence
        keySeq += pKey->vkCode;
        nKeySeq = keySeq.count();

        // Trigger
        if (keySeq == KeySequence({VK_CAPITAL, VK_TAB}))
            SwitchWindowWithSameOwner();
        else if (keySeq == KeySequence({VK_CAPITAL, 'W'}))
            KeyDown(VK_UP);
        else if (keySeq == KeySequence({VK_CAPITAL, 'S'}))
            KeyDown(VK_DOWN);
        else if (keySeq == KeySequence({VK_CAPITAL, 'A'}))
            KeyDown(VK_LEFT);
        else if (keySeq == KeySequence({VK_CAPITAL, 'D'}))
            KeyDown(VK_RIGHT);
    }
    else if (wParam == WM_KEYUP)
    {
        // Caps Lock release
        if ((nKeySeq == 1) && (keySeq == KeySequence({VK_CAPITAL})))
        {
            // Esc simulation when Caps Lock hold less than 200 msec
            // Enter simulation when Caps Lock hold more than 200 msec
            if (tCLHold.elapsed() < 500)
                KeyPress(VK_ESCAPE);
            else
                KeyPress(VK_RETURN);
        }

        // Trigger
        if (keySeq == KeySequence({VK_CAPITAL, VK_SPACE}))
            // Show command
            g_cmdPalette->activate();
        else if (keySeq == KeySequence({VK_CAPITAL, 'W'}))
            KeyUp(VK_UP);
        else if (keySeq == KeySequence({VK_CAPITAL, 'S'}))
            KeyUp(VK_DOWN);
        else if (keySeq == KeySequence({VK_CAPITAL, 'A'}))
            KeyUp(VK_LEFT);
        else if (keySeq == KeySequence({VK_CAPITAL, 'D'}))
            KeyUp(VK_RIGHT);

        // Delete from key sequence
        keySeq -= pKey->vkCode;
    }

    // Discard this message because it's combined with Caps Lock.
    if ((pKey->vkCode == VK_CAPITAL) || keySeq.startsWith(VK_CAPITAL))
        return true;

    return CallNextHookEx(NULL, nCode, wParam, lParam);
}

KeyboardHook::KeyboardHook(QObject *parent) : QObject(parent)
{
    g_cmdPalette = new CmdPalette();
    HHOOK keyboardHook = ::SetWindowsHookEx(WH_KEYBOARD_LL,
                                            KbHookProc,
                                            ::GetModuleHandle(NULL),
                                            0);
    if (::GetKeyState(VK_CAPITAL) == 1)
        KeyPress(VK_CAPITAL);
}

KeyboardHook::~KeyboardHook()
{
    delete g_cmdPalette;
}
