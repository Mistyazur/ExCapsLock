#include "keyboardhook.h"
#include "keysequence.h"
#include "cmdpalette.h"
#include "CmdItem/wincontrollor.h"
#include "TlHelp32.h"
#include <QTime>
#include <QDebug>

#define CAPSLOCK_INTERVAL   300

CmdPalette *g_cmdPalette = nullptr;

void SimulateKey(WORD key, BOOL down)
{
    INPUT input[1] = {0};
    input[0].type = INPUT_KEYBOARD;
    input[0].ki.wVk = key;
    input[0].ki.dwFlags = down ? 0 : KEYEVENTF_KEYUP;
    ::SendInput(_countof(input), input, sizeof(INPUT));
}

void SwitchWindowWithSameOwner()
{
    // Get foreground window process id and window handle

    HWND hWnd = ::GetForegroundWindow();
    if (hWnd == NULL)
        return;

    DWORD dwForegroundPid;
    ::GetWindowThreadProcessId(hWnd, &dwForegroundPid);

    // Get processes

    QHash<DWORD, QString> procIdNameHash;
    HANDLE hProcessSnap;
    PROCESSENTRY32 pe32 = {sizeof(PROCESSENTRY32), };

    hProcessSnap = ::CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (INVALID_HANDLE_VALUE == hProcessSnap)
        return;

    if (::Process32First(hProcessSnap, &pe32))
    {
        do {

            procIdNameHash.insert(pe32.th32ProcessID, QString::fromWCharArray(pe32.szExeFile));

        } while (::Process32Next(hProcessSnap, &pe32));
    }

    ::CloseHandle(hProcessSnap);

    // Bring tagert windowt to front

    WINDOWINFO winInfo = {sizeof(WINDOWINFO), };
    HWND hTargetWnd = NULL;

    while ((hWnd = ::GetWindow(hWnd, GW_HWNDNEXT)) != NULL)
    {
        ::GetWindowInfo(hWnd, &winInfo);
        if (!(winInfo.dwStyle & WS_DISABLED)
                && (winInfo.dwStyle & WS_VISIBLE)
                && !(winInfo.dwExStyle & WS_EX_TRANSPARENT))
        {
            if ((winInfo.rcWindow.left != 0) &&
                    (winInfo.rcWindow.top != 0) &&
                    (winInfo.rcWindow.right != 0) &&
                    (winInfo.rcWindow.bottom != 0))
            {
                DWORD dwPid;
                ::GetWindowThreadProcessId(hWnd, &dwPid);
                if (dwPid == dwForegroundPid)
                {
                    WinControllor::bringToFront(hWnd);
                    return;
                }
                else
                {
                    const QString &foregroundProcName = procIdNameHash.value(dwForegroundPid, "");
                    const QString &procName = procIdNameHash.value(dwPid, "");
                    if ((hTargetWnd == NULL)
                            && (!foregroundProcName.isEmpty())
                            && (foregroundProcName == procName))
                        hTargetWnd = hWnd;
                }
            }
        }
    }

    if (hTargetWnd != NULL)
        WinControllor::bringToFront(hTargetWnd);
}

DWORD CapsLockOperationThread(LPVOID lpParam)
{
    ::Sleep(CAPSLOCK_INTERVAL);

    int serialCapsCount = *((int *)lpParam);

    switch(serialCapsCount) {
    case 1:
        SimulateKey(VK_ESCAPE, 1);
        SimulateKey(VK_ESCAPE, 0);
        break;
    case 2:
        SimulateKey(VK_RETURN, 1);
        SimulateKey(VK_RETURN, 0);
        break;
    case 3:
        SimulateKey(VK_CAPITAL, 1);
        SimulateKey(VK_CAPITAL, 0);
        break;
    }

    return 0;
}

LRESULT CALLBACK KbHookProc(int nCode, WPARAM wParam, LPARAM lParam)
{
    static KeySequence keySeq = {};
    static bool bCompositeKey = false;
    PKBDLLHOOKSTRUCT pKey = (PKBDLLHOOKSTRUCT)lParam;

    // Output

    if (wParam == WM_KEYDOWN)
        qDebug()<<"Key Down: "<<pKey->vkCode<<(bool)(pKey->flags & LLKHF_INJECTED)<<"\tList: "<<keySeq;
    else
        qDebug()<<"Key Up:   "<<pKey->vkCode<<(bool)(pKey->flags & LLKHF_INJECTED)<<"\tList: "<<keySeq;

    // Key event injected was simulated.

    if (pKey->flags & LLKHF_INJECTED) {
        if (pKey->vkCode == VK_ESCAPE) {
            // Escape must be dealed
        } else {
            // Simulated keys are generated by capslock
            return CallNextHookEx(NULL, nCode, wParam, lParam);
        }
    }

    // Key event

    if (pKey->vkCode == VK_CAPITAL)
    {
        if (wParam == WM_KEYDOWN)
        {
            // Set false to check whether composite key
            bCompositeKey = false;

            keySeq += VK_CAPITAL;
        }
        else if (wParam == WM_KEYUP)
        {
            // Single capslock without other keys
            if (!bCompositeKey && (keySeq == KeySequence({VK_CAPITAL})))
            {
                static QTime tCLHold;
                static HANDLE hThread = NULL;
                static int serialCapsCount = 0;

                if (hThread != NULL) {
                    ::TerminateThread(hThread, 0);
                    ::CloseHandle(hThread);
                    hThread = NULL;
                }

                if (tCLHold.isValid()) {
                    if (tCLHold.elapsed() < CAPSLOCK_INTERVAL) {
                        ++serialCapsCount;
                    } else {
                        serialCapsCount = 1;
                    }
                    tCLHold.restart();
                } else {
                    serialCapsCount = 1;
                    tCLHold.start();
                }

                if (serialCapsCount > 0) {
                    hThread = ::CreateThread(NULL, 0,
                                             CapsLockOperationThread, &serialCapsCount,
                                             0, NULL);
                }
            }

            // Clear key sequence
            keySeq.clear();
        }

        // Discard this message because it's Caps Lock.

        return true;
    }
    else if (pKey->vkCode == VK_ESCAPE)
    {
        if (g_cmdPalette->isVisible())
        {
            if (wParam == WM_KEYUP)
                g_cmdPalette->deactivate();

            return true;
        }
    }
    else
    {
        if (keySeq.startsWith(VK_CAPITAL))
        {
            // Composite key

            bCompositeKey = true;

            // Add key

            if (wParam == WM_KEYDOWN)
            {
                keySeq += pKey->vkCode;

                // Trigger only at key down
                if (keySeq == KeySequence({VK_CAPITAL, VK_SPACE}))
                    g_cmdPalette->activate();
                else if (keySeq == KeySequence({VK_CAPITAL, VK_TAB}))
                    SwitchWindowWithSameOwner();
            }

            // Trigger at both key down and key up

            bool bKeyDown = (wParam == WM_KEYDOWN) ? true : false;
            if (keySeq == KeySequence({VK_CAPITAL, 'W'}))
                SimulateKey(VK_UP, bKeyDown);
            else if (keySeq == KeySequence({VK_CAPITAL, 'S'}))
                SimulateKey(VK_DOWN, bKeyDown);
            else if (keySeq == KeySequence({VK_CAPITAL, 'A'}))
                SimulateKey(VK_LEFT, bKeyDown);
            else if (keySeq == KeySequence({VK_CAPITAL, 'D'}))
                SimulateKey(VK_RIGHT, bKeyDown);

            // Remove key

            if (wParam == WM_KEYUP)
                keySeq -= pKey->vkCode;

            // Discard this message because it's combined with Caps Lock.

            return true;
        }
    }

    return CallNextHookEx(NULL, nCode, wParam, lParam);
}

KeyboardHook::KeyboardHook(QObject *parent) : QObject(parent)
{
    // Turn off caps lock

    if (::GetKeyState(VK_CAPITAL) == 1)
    {
        SimulateKey(VK_CAPITAL, 1);
        SimulateKey(VK_CAPITAL, 0);
    }

    // Create Command

    g_cmdPalette = new CmdPalette();

    // Install hook

    HHOOK keyboardHook = ::SetWindowsHookEx(WH_KEYBOARD_LL,
                                            KbHookProc,
                                            ::GetModuleHandle(NULL),
                                            0);
}

KeyboardHook::~KeyboardHook()
{
    delete g_cmdPalette;
}
